---
description: This package modifies some underlying fastHTML functionality so that
  Datastar is the underlying js library for DOM manipulation. This is currently implemented
  as a patch to the orignial library.
output-file: core.html
title: core

---



<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Response Processing
*The core of the Datastar integration involves replacing FastHTML's response processing to generate Server-Sent Events (SSE) instead of traditional HTML responses.*

This function processes FastHTML responses but removes HTMX-specific headers that aren't needed for Datastar:

::: {#cell-4 .cell execution_count=57}
``` {.python .cell-code}
from fasthtml.common import *
from starlette.testclient import TestClient
```
:::


::: {#cell-5 .cell execution_count=58}
``` {.python .cell-code}
# Test with actual FastHTML app and TestClient
app = FastHTML()

@app.get("/test-headers")
def test_headers():
    return Div("Content"), HttpHeader("X-Custom", "test-value")

client = TestClient(app)
response = client.get("/test-headers")
assert response.headers["X-Custom"] == "test-value"
```
:::


::: {#cell-6 .cell execution_count=60}
``` {.python .cell-code}
# Test fragment vs full page detection
app = FastHTML(title="Test App")
```
:::


::: {#cell-7 .cell execution_count=61}
``` {.python .cell-code}
@app.get("/fragment")
def fragment():
    return Div(id="content")("Fragment content")
```
:::


::: {#cell-8 .cell execution_count=62}
``` {.python .cell-code}
client = TestClient(app)
```
:::


Regular request gets full page

::: {#cell-10 .cell execution_count=63}
``` {.python .cell-code}
response = client.get("/fragment")
assert "<title>Test App</title>" in response.text
assert "<div id=\"content\">Fragment content</div>" in response.text
```
:::


Datastar request gets fragment only

::: {#cell-12 .cell execution_count=64}
``` {.python .cell-code}
response = client.get("/fragment?datastar=true")
# This would be just the fragment in a real implementation
```
:::


Test JSON responses become signals

::: {#cell-14 .cell execution_count=66}
``` {.python .cell-code}
app = FastHTML()

@app.get("/signals")
def signals():
    return {"counter": 42, "message": "hello"}

client = TestClient(app)
response = client.get("/signals")
assert response.json() == {"counter": 42, "message": "hello"}
```
:::


## Route Enhancement

---

### FastHTML.route

>      FastHTML.route (path:str=None, methods=None, name=None,
>                      include_in_schema=True, body_wrap=None, patch_mode=None,
>                      selector=None, use_view_transition=False)

*Enhanced route decorator with server-driven Datastar patch options*


Update HTTP method shortcuts

::: {#cell-18 .cell execution_count=68}
``` {.python .cell-code}
for method in all_meths:
    setattr(FastHTML, method, partialmethod(FastHTML.route, methods=method))
```
:::


::: {#cell-19 .cell execution_count=69}
``` {.python .cell-code}
# Test route with patch options
app = FastHTML()

@app.get("/append-item", patch_mode="append", selector="#list")
def append_item():
    return Li("New item")

# Verify the function has Datastar attributes
assert hasattr(append_item, '_datastar_mode')
assert append_item._datastar_mode == "append"
assert append_item._datastar_selector == "#list"
```
:::


## Endpoint Processing

## Monkey Patch Application


